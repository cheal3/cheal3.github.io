{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/08/31/hello-world/"},{"title":"마크다운 문법","text":"H1 은 = 여러개로 첫번째 두번째 세번째 print(\"코드는 pre code 태그로 감싸주거나 \") 1그레이브 엑센트 3개로 감싸준다 링크 CodePen에서 실행하기 인용 안녕하세요 이렇게 쓰니1코드","link":"/2020/09/01/1%EC%9D%BC%EC%B0%A8-2/"},{"title":"1일차","text":"thisthis 란? JS는 스크립트 언어로 인터프리터가 코드를 라인 단위로 읽고 해석한 뒤 실행시킨다. 인터프리터에 의해 현재 실행되는 자바스크립트 코드의 scope를 실행 컨텐스트라고 부른다. JS에서는 이런 실행 컨텍스트를 stack으로 관리하고 있으며 this는 현재 실행되는 코드의 실행 컨텍스트를 가리킨다. 이는 일반적으로 메소드를 호출한 객체가 저장되어 있는 속성이다. 기본적으로 this는 전역 객체를 가리키는데 Node환경에서는 global , Browser에서는 Window를 가리킨다. 1234567891011function MyClass() { this.property1 = &quot;value1&quot;;}MyClass.prototype.method1 = function(){ console.log(this.property1);}var my1 = new MyClass();my1.method1(); 메소드를 호출한 객체는 my1이고 method1은 메소드가 된다. method1()이 실행되면 메소드 내부에는 자바스크립트 엔진에 의해 this 속성이 생기게 된다. 이 this에는 method1을 호출한 my1 객체가 저장된다. 1. 일반 함수에서의 this 12345678910111213141516var data = 10; //1function outer(){ this.data = 20; //2 data = 30; //3 console.log(&quot;1. data = &quot; + data); console.log(&quot;2. this.data = &quot; + this.data); console.log(&quot;3. window.data = &quot; + window.data);}outer();/*1. data = 302. this.data = 303. window.data = 30*/ 일반 함수 내부에서는 this 가 전역 객체인 window 객체를 저장한다.2의 data는 window.data 와 동일하기 때문에 1의 data에 20이 저장된다.3에서는 먼저 지역 변수 내에서 data를 찾고 없으면 outer를 호출한 영역에서 찾기 때문에 마찬가지로 전역변수인 data에 30을 저장한다=&gt; 1,2,3의 data 모두 전역 변수인 data(1의 data)를 나타낸다. 2. 중첩 함수에서의 this 12345678910111213141516171819var data = 10; //1function outer(){ function inner(){ this.data = 20; //2 data = 30; //3 console.log(&quot;1. data = &quot; + data); console.log(&quot;2. this.data = &quot; + this.data); console.log(&quot;3. window.data = &quot; + window.data); } inner();}outer();/*1. data = 302. this.data = 303. window.data = 30*/ 일반 중첩 함수에서 this 역시 window가 된다.2의 this.data는 1의 data와 동일하므로 1의 data에 20이 저장된다.3의 data는 우선 지역 변수 내에서 data를 찾고, 없다면 outer를 호출한 영역에서 data를 찾습니다. inner와 outer 모두 data가 없기 때문에, 3의 data 역시 1의 전역 변수인 data가 된다.=&gt; 1,2,3의 data 모두 전역 변수인 data(1의 data)를 나타낸다. 3. Event Listener에서의 this 123456789101112131415var data = 10; //1$(&quot;#myButton&quot;).click(function() { this.data = 20; //2 data = 30; //3 console.log(&quot;1. data = &quot; + data); console.log(&quot;2. this.data = &quot; + this.data); console.log(&quot;3. window.data = &quot; + window.data); });/*1. data = 302. this.data = 203. window.data = 30*/ 이벤트 리스너에서는 this가 이벤트를 발생시킨 객체가 된다.그러므로 this가 #myButton이 되고 2는 #myButton에 data라는 property를 동적으로 추가하는 구문이 된다.3의 data는 우선 지역 변수내에서 data를 찾고 없다면 상위 영역에서 data를 찾는다. 결국 3의 data는 1의 전역 변수 data가 되어 30을 저장한다 4. 메소드에서의 this 123456789101112131415161718192021var data = 10; //1function MyClass(){ this.data = 0;}MyClass.prototype.method1 = function(){ this.data = 20; //2 data = 30; //3 console.log(&quot;1. data = &quot; + data); console.log(&quot;2. this.data = &quot; + this.data); console.log(&quot;3. window.data = &quot; + window.data); } var my1 = new MyClass(); my1.method1();/*1. data = 302. this.data = 203. window.data = 30*/ (객체의 property가 함수인 경우 이를 메소드라고 부른다)메소드에서는 this가 메소드를 호출한 객체가 된다.2의 data는 객체의 property가 되어 코드 my1.data에 20이 저장된다.3의 data는 우선 지역 변수 내에서 data를 찾고, 없으면 상위 영역에서 data를 찾게 됩니다. 결국 3의 data는 1의 전역 변수 data가 되어 30을 저장한다. 5. 메소드 내부의 중첩 함수에서의 this 123456789101112131415161718192021222324var data = 10; //1function MyClass(){ this.data = 0;}MyClass.prototype.method1 = function(){ function inner(){ this.data = 20; //2 data = 30; //3 console.log(&quot;1. data = &quot; + data); console.log(&quot;2. this.data = &quot; + this.data); console.log(&quot;3. window.data = &quot; + window.data); } inner();} var my1 = new MyClass(); my1.method1();/*1. data = 302. this.data = 203. window.data = 30*/ 객체의 메소드 내부에서 만들어지는 중첩 함수에서 this는 객체가 아닌 window가 된다.2의 data는 1의 전역 변수가 되어 1의 data에 20이 저장된다.3의 data는 우선 지역 변수 내에서 data를 찾고, 없으면 상위 영역에서 data를 찾게 됩니다. 결국 3의 data는 1의 전역 변수 data가 되어 30을 저장한다.=&gt; 1,2,3의 data 모두 전역 변수인 data(1의 data)를 나타낸다. 요약 this가 만들어지는 경우 this가 가리키는 것 일반 함수 window 중첩 함수 window 이벤트 이벤트 객체 메소드 메소드 객체 메소드 내부 중첩 함수 window 출처 : https://beomy.tistory.com/6","link":"/2020/09/01/1%EC%9D%BC%EC%B0%A8-3/"},{"title":"1일차","text":"JS 문법 공부(ES 6)인턴 1일차 JS문법공부 (ES 6) 하고 난 뒤에 node.js / React.js / db 설계 공부예정 ES 6 사수님께서 ES6를 공부하라고 하셔서 ES6가 뭐고 왜 쓰는지 먼저 알아 보았다.초기에는 특정 브라우저에서만 동작하는 JS가 있어서 모든 브라우저에서 호환이 되는표준 규격을 만들었고 그것이 ECMA 국제기구에서 만든 ECMA Script이다.그리고 회사에서 사용하는 React 등 최신 프레임워크들은 ES6를 기반으로 하고 있기 때문에ES6를 공부하게 된 것이다. 추가적으로 유튜브에서 공부할 때 보았던 Babel이라는 트랜스파일러를 사용하는 이유도 알 수 있었는데웹 브라우저에서 완벽하게 지원되지 않아서 상위버전 ES를 하위버전 ES로 변환해 주는 역할을 한다고 한다. ES6에서 대표적으로 추가된 기능은 3가지 정도가 있다. 1. Var와 Let , Const 일단 세가지 키워드 모두 선언 방법은 동일하다. 123var v1 = 4;let v2 = 4;const v3 = 4; ES6에서는 var 대신 let과 const를 쓴다고 하는데 이들의 차이점을 알아보았다. 1.1 호이스팅 (Hoisting) var로 선언한 변수는 호이스팅이 된다는 특징이 있다. 호이스팅이란 끌어올린다는 뜻으로 변수의 선언보다 대입이 먼저 이루어질 때 일어난다 123hoisting = 1;var hoisting;console.log(hoisting); // 1 하지만 let과 const는 호이스팅을 시도할 경우 에러가 난다. 1234hoisting = 1;let hoisting;console.log(hoisting); // error 1234hoisting = 1;const hoisting;console.log(hoisting); // error 1.2 변수 스코프 var는 함수 스코프만 적용되고 블록 스코프는 적용되지 않는다. 12345678//함수 스코프var a = 100;function f() { var a = 200; console.log(a); // 200}f();console.log(a); //100 12345678//블록 스코프var a = 100;if(a&gt;0){ var a =200; /*var a = 300; // error가 발생하지 않는다 */ console.log(a); //200}console.log(a); //200 블록 스코프 예제에서 두번째 콘솔에 찍힌 a값이 200인 이유는 var변수 사용시 함수 블록에 대한 스코프만 제공하기 때문에 변수가 블록 안에 있던 밖에 있던 공유되기 때문이다. 1234567let a = 100;if(a&gt;0){ let a = 200; /*let a = 100; // error ( a = 100; 은 가능하다.)*/ console.log(a); // 200}console.log(a); //100 1234567const a = 100;if(a&gt;0){ const a = 200; /*const a = 100; // error ( a = 100; 도 불가능하다.)*/ console.log(a); // 200}console.log(a); //100 let 과 const는 모든 블록에 대한 스코프가 생기고 중복 선언이 불가능하다. 2. 화살표 함수(Arrow Function) ES6에서는 화살표 함수를 이용해 함수를 정의하는 방법이 추가되었다. 일반적인 JS의 함수 선언 방법은 다음과 같다 123function FunctionName(){} 그리고 이렇게 선언된 함수는 다음과 같이 실행할 수 있다 1FunctionName(); 2.1 사용법 화살표 함수는 보다 간편한 방법으로 선언하기 위해 다음과 같이 선언한다. 1234567891011121314151617() =&gt; { ... } // 매개변수가 없을 경우 x =&gt; { ... } // 매개변수가 한 개인 경우, 소괄호를 생략할 수 있다.(x, y) =&gt; { ... } // 매개변수가 여러 개인 경우, 소괄호를 생략할 수 없다.x =&gt; { return x * x } // single line blockx =&gt; x * x // 함수 몸체가 한줄의 구문이라면 중괄호를 생략할 수 있으며 암묵적으로 return된다. 위 표현과 동일하다.() =&gt; { return { a: 1 }; }() =&gt; ({ a: 1 }) // 위 표현과 동일하다. 객체 반환시 소괄호를 사용한다.() =&gt; { // multi line block. const x = 10; return x * x;}; 화살표 함수는 익명 함수로만 사용할 수 있다. 12const pow = x =&gt; x*x;console.log(pow(10)); //100 2.2 this 일반 함수와 화살표 함수의 가장 큰 차이점은 this이다. 일반 함수의 경우 함수를 호출할 때 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정된다. 하지만 화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다. (Lexical this) 12345678910function Prepixer(prefix){ this.prefix = prefix;}Prefixer.prototype.prefixArray = function (arr){ // this는 상위 스코프인 prefixArray 메소드 내의 this를 가리킨다. return arr.map(x =&gt; `${this.prefix} #{x}`);};const pre = new Prefixer('Hi');console.log(pre.prefixArray(['Lee', 'Kim'])); 화살표 함수는 call,apply,bind 메소드를 사용하여 this를 변경할 수 없다. 3. Promise 싱글스레드인 자바스크립트에서 비동기 처리를 위해서 콜백을 사용해왔다.덕분에 비동기 처리를 온전히 해낼 수 있었지만 여러가지 단점들이 있었는데비동기 처리를 중첩시켜서 표현하므로 에러, 예외처리가 어렵다는 것과 중첩으로 인한 복잡도가 증가한다는 것이었다.크게 이 두가지 단점을 해결하기 위해서 생겨난 것이 Promise 이다.","link":"/2020/09/01/1%EC%9D%BC%EC%B0%A8/"},{"title":"2일차","text":"Node.jsNode.js는 Google의 V8 JavaScript 엔진에 기반한 서버 측 기술이다. 쓰레드나 별도 프로세스 대신 비동기 이벤트 위주 I/O를 사용하는 시스템으로 간단한 작업을 수행하지만 접근 빈도가 높은 웹 어플리케이션에 이상적이다. 전통적인 웹 서버 Node 웹 리소스가 요청될 때마다 요청을 처리하기 위해 매번 별도의 스레드를 생성하거나 새로운 프로세스를 호출한다. 이러한 방식은 많은 양의 리소스를 붙잡아 두게 된다. 매 요청마다 태스크를 새롭게 생성하지 않고 특정 이벤트를 기다리고 있다가 해당 이벤트가 발생하면 응답한다. Node는 이벤트 기능이 완료되는 것을 기다리는 동안 다른 요청이 들어오는 것을 차단하지 않으며 이벤트는 비교적 간단한 이벤트 루프 내에서 들어온 순서대로 처리된다. Hello World! 12345678//helloworld.jsvar http = require('http'); // 1http.createServer(function (req,res){ // 2 res.writeHead(200,{'content-type': 'text/plain'}); // 3 res.end(&quot;Hello, World!\\n&quot;); //4}).listen(8124); // asynchronousconsole.log('Server running on 8124'); 다음과 같이 코드를 작성하고 명령 창에서 다음을 입력한다. node helloworld.js 프로그램이 성공적으로 실행되면 다음과 같이 출력된다. Server running on 8124 그 다음 아무 브라우저나 사용해서 `localhost:8124`를 사용하면 아래와 같은 웹 페이지가 표시된다. helloworld.js 의 코드를 살펴보면 Node의 기능 대부분은 모듈이라고 불리는 외부 어플리케이션 및 라이브러리를 통해 제공된다. 1의 코드는 HTTP 모듈을 로드해서 로컬 변수 http에 할당한다. HTTP 모듈은 기본 HTTP 기능을 제공하여 어플리케이션이 네트워크에 접근할 수 있게 해준다. createServer를 사용하여 새로운 서버가 생성되며, 매개변수로 익명 함수가 전달된다. 이 익명 함수는 requestListener 함수로 서버 요청(http.ServerRequest)과 서버 응답(http.ServerResponse)이라는 매개변수들을 가진다. http.ServerResponse 개체는 writeHead라는 메소드를 가지는데 응답 상태와 content-type을 제공하는 응답 헤더를 전송하고 있다. 헤더 생성 코드 다음은 메시지를 쓰는 명령이다. end 메소드는 두 개의 매개변수를 가진다. 문자열이나 버퍼가 될 수 있는 데이터 문자열일 경우 인코딩 방식을 지정 (utf-8이 아닐 경우에만 필요) 또한 4의 코드는 다음과 같이 쓸 수도 있다. 12res.write(&quot;Hello, World!\\n&quot;);res.end();","link":"/2020/09/02/2%EC%9D%BC%EC%B0%A8/"},{"title":"2일차) React.js","text":"1. Hello World 가장 단순한 React 예시는 다음과 같이 생겼다. 1234ReactDOM.render( &lt;h1&gt;Hello, World!&lt;/h1&gt;, document.getElementById('root')); 위 코드는 페이지에 “Hello, world!”라는 제목을 보여준다. CodePen에서 실행하기 2. JSX 아래의 변수 선언을 살펴보자 1const element = &lt;h1&gt;Hello, World!&lt;/h1&gt;; 위와 같은 태그 문법을 JSX라고 하며 JavaScript를 확장한 문법이다. JSX는 React element를 생성한다. JSX에 표현식 표함하기 아래 예시에서는 `name` 이라는 변수를 선언한 후 중괄호로 감싸 JSX 안에 사용하였다. 1234567const name = 'dong wook';const element = &lt;h1&gt;Hello , {name}&lt;/h1&gt;;ReactDOM.render( element, document.getElementById('root')); JSX의 중괄호 안에는 유효한 모든 JavaScript표현식을 넣을 수 있다. 예를 들어 2+2 , user.firstName 또는 formatName(user) 등은 모두 유효한 JavaScript 표현식이다. 아래 예시에서는 JavaScript 함수 호출의 결과인 formatName(user)을 &lt;h1&gt; 엘리멘트에 포함했다. 1234567891011121314151617181920function formatName(user){ return user.firstName + ' ' + user.lastName;}const user = { firstName: &quot;dong wook&quot;, lastName: 'choi'};const element = ( &lt;h1&gt; Hello, {formatName(user)}! &lt;/h1&gt;);ReactDOM.render( element, document.getElementById('root')); CodePen에서 실행하기 JSX도 표현식이다 컴파일이 끝나면, JSX 표현식이 정규 JavaScript 함수 호출이 되고 JavaScript 객체로 인식된다.즉, JSX를 if 구문 및 for loop 안에 사용하고, 변수에 할당하고 , 인자로서 받아들이고, 함수로부터 반환 할 수 있다. 1234567function getGreeting(user){ if(user){ return &lt;h1&gt;Hello , {formatName(user)}!&lt;/h1&gt;; } return &lt;h1&gt;Hello, Stranger. &lt;/h1&gt;;} JSX 속성 정의 속성에 따옴표를 이용해 문자열 리터럴을 정의할 수 있다. 1const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;; 중괄호를 사용하여 어트리뷰트에 JavaScript표현식을 삽입할 수도 있다. 1const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;; 어트리뷰트에 JavaScript 표현식을 삽입할 때 중괄호 주변에 따옴표를 입력하지 말자.따옴표 또는 중괄호 중 하나만 사용하고 , 동일한 어트리뷰트에 두 가지를 동시에 사용하면 안된다. 경고 JSX는 HTML보다는 JavaScript에 가깝기 때문에, React DOM은 HTML 어트리뷰트 이름 대신 camelCase 프로퍼티 명명 규칙을 사용한다.예를 들어 , JSX에서 class는 className 이 되고 tabindex는 tabIndex 가 된다. JSX로 자식 정의 태그가 비어있다면 XML처럼 `/>` 를 이용해 바로 닫아주어야 한다. 1const element = &lt;img src={user.avatarUrl} /&gt;; JSX 태그는 자식을 포함할 수 있다. 123456const element = ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;h2&gt;Good to see you here.&lt;/h2&gt; &lt;/div&gt;); JSX는 주입 공격을 방지한다 JSX에 사용자 입력을 삽입하는 것은 안전하다. 12const title = response.potentiallyMaliciousInput;const element = &lt;h1&gt;{title}&lt;/h1&gt;; 기본적으로 React DOM은 JSX에 삽입된 모든 값을 렌더링하기 전에 이스케이프 하므로, 애플리케이션에서 명시적으로 작성되지 않은 내용은 주입되지 않는다. 모든 항목은 렌더링 되기 전에 문자열로 반환된다. 이런 특성으로 인해 XSS 공격을 방지할 수 있다. JSX는 객체를 표현한다. Babel은 JSX를 `React.createElement()` 호출로 컴파일한다. 다음 두 예시는 동일하다. 12345const element = ( &lt;h1 className = &quot;greeting&quot;&gt; Hello, World! &lt;/h1&gt;); 12345const element = React createElement( 'h1', {className: 'greeting'}, 'Hello, World!'); React.createElement() 는 버그가 없는 코드를 작성하는 데 도움이 되도록 몇 가지 검사를 수행하며, 기본적으로 다음과 같은 객체를 생성한다. 12345678// 주의: 다음 구조는 단순화되었음const element = { type: 'h1', props: { className: 'greeting', children: 'Hello, world!' }}; 이러한 객체를 “React 엘리먼트”라고 하며, 이를 화면에 표시하려는 항목에 대한 설명이라고 생각할 수 있다. React는 이러한 객체를 읽은 후 DOM을 구성하고 최신으로 유지하는 데 이러한 객체를 사용한다. 팁 ES6 및 JSX 코드가 올바르게 표시되도록 편집기에 “Babel” 언어 설정을 사용하는 것을 권장.","link":"/2020/09/02/2%EC%9D%BC%EC%B0%A8%20React_1/"},{"title":"2일차) React.js-2","text":"엘리먼트 렌더링 엘리먼트는 React 앱의 가장 작은 단위이다. 엘리먼트는 화면에 표시할 내용을 기술한다. 1const element = &lt;h1&gt;Hello, World!&lt;/h1&gt;; 브라우저 DOM 엘리먼트와 달리 React 엘리먼트는 일반 객체이며(plain object) 쉽게 생성할 수 있다. React DOM은 React 엘리먼트와 일치하도록 DOM을 업데이트 한다. 주의 더 널리 알려진 개념인 “컴포넌트”와 엘리먼트를 혼동할 수 있다. DOM에 엘리먼트 렌더링하기 HTML 파일 어딘가에 &lt;div&gt;가 있다고 가정해 보자. 1&lt;div id = &quot;root&quot;&gt; &lt;/div&gt; 이 안에 들어가는 모든 엘리먼트를 React DOM에서 관리하기 때문에 이것을 “루트” DOM 노드라고 부른다. React로 구현된 애플리케이션은 일반적으로 하나의 루트 DOM 노드가 있다. React를 기존 앱에 통합하려는 경우 원하는 만큼 많은 수의 독립된 루트 DOM 노드가 있을 수 있다. React 엘리먼트를 루트 DOM 노드에 렌더링하려면 둘 다 ReactDOM.render()로 전달하면 된다. 12const element = &lt;h1&gt;Hello, World!&lt;/h1&gt;;ReactDOM.render(element,document.getElementById('root')); CodePen에서 실행하기 위 코드를 실행하면 화면에 “Hello, World!” 가 보인다. 렌더링 된 엘리먼트 업데이트하기 React 엘리먼트는 불변객체 이다. 엘리먼트를 생성한 이후에는 해당 엘리먼트의 자식이나 속성을 변경할 수 없다. 엘리먼트는 영화에서 하나의 프레임과 같이 특정 시점의 UI를 보여준다. 지금까지 소개한 내용을 바탕으로 하면 UI를 업데이트하는 유일한 방법은 새로운 엘리먼트를 생성하고 이를 ReactDOM.render()로 전달하는 것이다. 예시로 똑딱거리는 시계를 살펴보자. 123456789101112function tick() { const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render(element, document.getElementById('root'));}setInterval(tick, 1000); CodePen에서 실행하기 위 함수는 setInterval() 콜백을 이용해 매 초마다 ReactDOM.render()를 호출합니다. 주의실제로 대부분의 React 앱은 ReactDOM.render()를 한 번만 호출합니다. 변경된 부분만 업데이트하기 React DOM은 해당 엘리먼트와 그 자식 엘리먼트를 이전의 엘리먼트와 비교하고 DOM을 원하는 상태로 만드는데 필요한 경우에만 DOM을 업데이트한다. 개발자 도구를 이용해 마지막 예시를 살펴보면 이를 확인할 수 있다. 매초 전체 UI를 다시 그리도록 엘리먼트를 만들었지만 React DOM은 내용이 변경된 텍스트 노드만 업데이트했다.","link":"/2020/09/02/2%EC%9D%BC%EC%B0%A8%20React_2/"},{"title":"React와 Node.js로 만드는 고객 관리 시스템 개발-2","text":"소스코드 작성하기안경잡이개발자 님은 IDE로 VS Code를 사용하셨는데 나는 그냥 쓰던 Atom을 이용해서 개발했다. 기본적으로 React는 App.js 라는 이름으로 메인 자바스크립트를 관리 할 수 있다. 실제 HTML 문서에서 태그에 해당하는 내용은 App.js가 채우게 된다. ​ 1234567891011&lt;p&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.&lt;/p&gt; &lt;a className=&quot;App-link&quot; href=&quot;https://reactjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &gt; Learn React &lt;/a&gt; 이 부분을 아래와 같이 변경하였다. 1&lt;h2&gt; 이렇게 바꾸면 바뀔까 &lt;/h2&gt; Ctrl+S 으로 저장하면 재 가동하지 않아도 소스코드가 컴파일 되어 바로 웹 사이트에서 변경되는 것을 확인할 수 있었다.","link":"/2020/09/02/project-2/"},{"title":"React와 Node.js로 만드는 고객 관리 시스템 개발-3","text":"소스코드 관리하기소스코드를 수정하며 프로젝트의 윤곽을 이해해보자 App.js App.js는 실질적인 웹 사이트 화면에 대한 내용 출력을 담당하는 부분이다. 현재 지식으로도 눈치껏 이해가 가능하다. 12345678910111213141516import React from 'react';import logo from './logo.svg';import './App.css';function App() { return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;h2&gt; 이렇게 바꾸면 바뀔까 &lt;/h2&gt; &lt;/header&gt; &lt;/div&gt; );}export default App; App.css App.css는 App.js와 연동되어 웹사이트 메인 부분의 디자인 을 담당한다 기능을 대략적으로 알기 위해서 내용을 전부 지우고 아래의 코드만 들어가도록 수정하였다. 123.gray-background {background: darkgray;} 그런다음 App.js 에 가서 다음과 같이 코드를 수정하자 1&lt;div className=&quot;gray-background&quot;&gt; index.html index.html 은 public 디렉토리 아래에 있다. &lt;div id=&quot;root&quot;&gt; &lt;/div&gt; 라는 부분이 있는데, 이 root 영역에 실제로 App.js의 내용이 출력된다. 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;Web site created using create-react-app&quot; /&gt; &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;%PUBLIC_URL%/logo192.png&quot; /&gt; &lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot; /&gt; &lt;title&gt;React App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 여기~~~~~~~ --&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; README.md 많이보던 md 파일 깃허브에 올라가 프로젝트 소개 등의 내용이 들어가는 공간이다. 전부 수정하면 다음과 같은 결과를 얻을 수 있다. 글자가 어디갔나 했더니 왼쪽 구석에 작게 써있는 것을 발견하였다. 적용 결과 깃허브로 관리하기 깃허브에 들어가서 Repository를 만들고 프로젝트 폴더로 이동한뒤 다음과 같이 작성하자 1234git initgit config user.name &quot;아이디&quot;git config user.email 이메일git remote add origin 깃허브 주소 그런다음 아톰에 들어가면 다음과 같은 화면을 볼 수 있다. 사진에 보이는 github.atom.io/login 에 들어가면 다음과 같은 화면이 나온다. 이상태에서 비밀번호를 치고 진행하면 토큰값을 얻을 수 있는데 이를 Atom으로 가서 입력하면 연동이 된다. 연동이 된 상태에서 Add+commit 을 하면 다음과 같이 깃허브에 올라간다.","link":"/2020/09/02/project-3/"},{"title":"React와 Node.js로 만드는 고객 관리 시스템 개발-4","text":"고객 컴포넌트 만들기컴포넌트란 웹 문서에서 어떠한 내용을 보여주기 위한 기본적인 단위이다. 고객 컴포넌트란 한 명의 고객에 대한 정보를 보여주기 위한 기능이라고 보면 되겠다. Customer.js src 디렉터리 아래에 components 디렉터리를 만들고 Customer.js 컴포넌트를 생성해주자. 1234567891011121314151617//Customer.jsimport React from 'react';class Customer extends React.Component{ render(){ return( &lt;div&gt; &lt;h2&gt;염소&lt;/h2&gt; &lt;p&gt;031223&lt;/p&gt; &lt;p&gt;여자&lt;/p&gt; &lt;p&gt;대학생&lt;/p&gt; &lt;/div&gt; ) }}export default Customer; App.js App.js 에서 방금 만든 Customer 컴포넌트를 사용해 보자 12345678910111213import React, {Component} from 'react';import Customer from './components/Customer'import './App.css';class App extends Component{ render(){ return ( &lt;Customer/&gt; );}}export default App; 다음과 같은 오류가 나왔는데 React는 오류가 발생하면 이렇게 나오는구나 신기했다. 오류를 고쳐주면 다음과 같은 결과창이 나온다. 적용 결과 Props를 이용한 구조화 Props를 이용해서 App.js 에서 데이터를 가진 상태에서 고객에 대한 정보를 출력하도록 구조화 하자 12345678910111213141516171819202122232425//App.jsimport React, {Component} from 'react';import Customer from './components/Customer'import './App.css';const customer = { 'name': '염소', 'birthday':'031223', 'gender':'여자', 'job':'대학생'}class App extends Component{ render(){ return ( &lt;Customer name={customer.name} birthday={customer.birthday} gender={customer.gender} job={customer.job}/&gt; ); }}export default App; 그런다음 Customer.js 에 가서 다음과 같이 코드를 수정하자 12345678910111213141516171819import React from 'react';class Customer extends React.Component{ render(){ return( &lt;div&gt; &lt;h2&gt;{this.props.name}&lt;/h2&gt; &lt;p&gt;{this.props.birthday}&lt;/p&gt; &lt;p&gt;{this.props.gender}&lt;/p&gt; &lt;p&gt;{this.props.job}&lt;/p&gt; &lt;/div&gt; ) }}export default Customer; 확인해보면 결과는 동일한 것을 알 수 있다.","link":"/2020/09/02/project-4/"},{"title":"React와 Node.js로 만드는 고객 관리 시스템 개발","text":"Create React App으로 리액트 프로젝트 시작하기 Node.js를 설치하면 패키지 매니저 도구 npm이 자동으로 설치된다. 1npm install -g create-react-app 프로젝트 폴더로 이동해서 React 프로젝트를 생성해 주고 해당 프로젝트 폴더로 이동하자. 12create-react-app react_examplecd react_example yarn start를 실행하라고 하였는데 오류가 나서 yarn을 다시 설치해 주었다. 12npm install yarn -gyarn start 기본 포트번호 localhost:3000 로 접속하면 다음과 같은 화면이 나온다","link":"/2020/09/02/project-1/"},{"title":"React와 Node.js로 만드는 고객 관리 시스템 개발-5","text":"고객 컴포넌트 내용 분리하기어제는 리액트 프로젝트를 만들고 고객 한명의 정보를 담아 출력하는 Customer.js 컴포넌트를 만들고 깃허브에 올리는 것 까지 하였다. 오늘은 한 명의 고객이 가지고 있는 정보가 많아 다루기 어려울 때 컴포넌트의 내용을 분리하는 방법을 알아보자. App.js 전에 작성했던 회원의 정보에 id 와 image 정보를 추가해 보자. 123456789101112131415161718192021222324252627import React, {Component} from 'react';import Customer from './components/Customer'import './App.css';const customer = { 'id': 1, 'image': 'https://placeimg.com/64/64/any', 'name': '염소', 'birthday':'031223', 'gender':'여자', 'job':'대학생'}class App extends Component{ render(){ return ( &lt;Customer id = {customer.id} image = {customer.image} name={customer.name} birthday={customer.birthday} gender={customer.gender} job={customer.job}/&gt; ); }}export default App; https://placeimg.com/64/64/any 를 사용하면 원하는 픽셀크기와 원하는 카테고리의 랜덤 사진을 가져올 수 있다. Customer.js Customer.js 는 고객에 대한 정보를 출력하는 역할을 수행한다고 하였다. 그래서 출력할 내용이 많으면 적절히 구조화하여 관리하는 것이 중요하다. 프로젝트에서는 Customer를 CustomerProfile과 CustomerInfo 두 가지 요소로 구조화하였다. 12345678910111213141516171819202122232425262728293031323334353637import React from 'react';class Customer extends React.Component{ render(){ return( &lt;div&gt; &lt;CustomerProfile id={this.props.id} image={this.props.image} name={this.props.name}/&gt; &lt;CustomerInfo birthday={this.props.birthday} gender={this.props.gender} job={this.props.job}/&gt; &lt;/div&gt; ) }}class CustomerProfile extends React.Component{ render(){ return( &lt;div&gt; &lt;img src = {this.props.image} alt=&quot;profile&quot;/&gt; &lt;h2&gt;{this.props.name}({this.props.id})&lt;/h2&gt; &lt;/div&gt; ) }}class CustomerInfo extends React.Component{ render(){ return( &lt;div&gt; &lt;p&gt;{this.props.birthday}&lt;/p&gt; &lt;p&gt;{this.props.gender}&lt;/p&gt; &lt;p&gt;{this.props.job}&lt;/p&gt; &lt;/div&gt; ) }}export default Customer; 적용 결과 App.js 다시 App.js 로 돌아와서 이번에는 한 명이 아닌 3명의 고객의 정보가 들어있는 customers 배열이 있다고 가정해보자. 12345678910111213141516171819202122232425262728293031//App.jsimport React, {Component} from 'react';import Customer from './components/Customer'import './App.css';const customers = [{ 'id': 1, 'image': 'https://placeimg.com/64/64/any', 'name': '염소', 'birthday':'031223', 'gender':'여자', 'job':'대학생'},{'id': 2,'image': 'https://placeimg.com/64/64/2','name': '최동욱','birthday': '951211','gender': '남자','job': '인턴'},{'id': 3,'image': 'https://placeimg.com/64/64/3','name': '털보','birthday': '961127','gender': '남자','job': '개'}] 위와 같은 경우 기존의 방식을 사용하면 코드가 굉장히 길어지기 때문에 다음과 같이 고쳐주자. App class를 다음과 같이 바꿔주자 1234567891011121314class App extends Component{ render(){ return ( &lt;div&gt; {customers.map(c =&gt; { return &lt;Customer key = {c.id} id = {c.id} image = {c.image} name = {c.name} birthday = {c.birthday} gender = {c.gender} job = {c.job}/&gt; } ) } &lt;/div&gt; ); } }export default App; map 이란 특정한 List가 있을 때 해당 리스트의 각 원소에 특정한 문법을 적용한 결과 리스트를 반환한다. 다시 말해서 customers 의 각 원소들에 대한 Element를 반환하는 것이다. map을 이용해 다수의 정보를 출력할 때는 key라는 이름의 Props를 사용해야 한다. 적용 결과","link":"/2020/09/03/project-5/"},{"title":"React와 Node.js로 만드는 고객 관리 시스템 개발-6","text":"Material UI를 적용하여 테이블 만들기Material UI를 이용해서 디자인을 하는 법을 알아보자. Material UI는 React에서 가장 많이 사용하는 디자인 프레임워크라고 한다. 저번 인턴때 쓰던 Bootstrap UI와 비슷하다. Material UI: https://material-ui.com/getting-started/installation/ Material UI 설치 서버를 종료한뒤 터미널에서 다음과 같은 명령어를 입력하자 12npm install @material-ui/coreyarn start 테이블 만들어보기 고객 목록에 대한 정보는 테이블 형태로 출력하는 것이 효과적이다 테이블 사용 예제 : https://material-ui.com/demos/tables/ 한 명의 고객이 하나의 행을 차지하도록 컴포넌트를 수정해주자 Customer.js123456789101112131415161718192021import React from 'react';import TableRow from '@material-ui/core/TableRow';import TableCell from '@material-ui/core/TableCell';class Customer extends React.Component{ render(){ return( &lt;TableRow&gt; &lt;TableCell&gt;{this.props.id}&lt;/TableCell&gt; &lt;TableCell&gt;&lt;img src = {this.props.image} alt = &quot;profile&quot;/&gt;&lt;/TableCell&gt; &lt;TableCell&gt;{this.props.name}&lt;/TableCell&gt; &lt;TableCell&gt;{this.props.birthday}&lt;/TableCell&gt; &lt;TableCell&gt;{this.props.gender}&lt;/TableCell&gt; &lt;TableCell&gt;{this.props.job}&lt;/TableCell&gt; &lt;/TableRow&gt; ) }}export default Customer; 이후에 App.js에서 테이블의 Body 부분에서 고객에 대한 정보를 하나씩 출력하도록 처리해주자 App.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import React, {Component} from 'react';import Customer from './components/Customer'import './App.css';import Table from '@material-ui/core/Table';import TableHead from '@material-ui/core/TableHead';import TableBody from '@material-ui/core/TableBody';import TableRow from '@material-ui/core/TableRow';import TableCell from '@material-ui/core/TableCell';const customers = [{ 'id': 1, 'image': 'https://placeimg.com/64/64/any', 'name': '염소', 'birthday':'031223', 'gender':'여자', 'job':'대학생'},{'id': 2,'image': 'https://placeimg.com/64/64/2','name': '최동욱','birthday': '951211','gender': '남자','job': '인턴'},{'id': 3,'image': 'https://placeimg.com/64/64/3','name': '털보','birthday': '961127','gender': '남자','job': '개'}]class App extends Component{ render(){ return ( &lt;div&gt; &lt;Table&gt; &lt;TableHead&gt; &lt;TableRow&gt; &lt;TableCell&gt; 번호 &lt;/TableCell&gt; &lt;TableCell&gt; 이미지 &lt;/TableCell&gt; &lt;TableCell&gt; 이름 &lt;/TableCell&gt; &lt;TableCell&gt; 생년월일 &lt;/TableCell&gt; &lt;TableCell&gt; 성별 &lt;/TableCell&gt; &lt;TableCell&gt; 직업 &lt;/TableCell&gt; &lt;/TableRow&gt; &lt;/TableHead&gt; &lt;TableBody&gt; {customers.map(c =&gt; {return &lt;Customer key={c.id} id={c.id} image={c.image} name={c.name} birthday={c.birthday} gender={c.gender} job={c.job} /&gt;} ) } &lt;/TableBody&gt; &lt;/Table&gt;&lt;/div&gt; ); }}export default App; 적용 결과 CSS 적용하기 withStyles 라이브러리를 이용해서 CSS를 적용할 수 있다. App.js1234567891011121314151617181920212223import React, {Component} from 'react';import Customer from './components/Customer'import './App.css';import Table from '@material-ui/core/Table';import TableHead from '@material-ui/core/TableHead';import TableBody from '@material-ui/core/TableBody';import TableRow from '@material-ui/core/TableRow';import TableCell from '@material-ui/core/TableCell';import { withStyles } from '@material-ui/core/styles';const styles = theme =&gt; ({ root: { width: &quot;100%&quot;, marginTop: theme.spacing.unit * 3, overflowX: &quot;auto&quot; }, table: { minWidth: 1080 }});...","link":"/2020/09/03/project-6/"},{"title":"React와 Node.js로 만드는 고객 관리 시스템 개발-7","text":"Node.js Express 서버 구축하기Node.js Express를 React 클라이언트 서비스와 연동하는 방법에 대해서 알아보자. 이전까지는 클라이언트 파트를 구축하여 개발하고 있었으므로 서버 모듈을 개발하여 클라이언트와 연동시키면 된다. 프로젝트 루트 폴더에서 client 라는 이름의 디렉터리를 생성하자 그런 다음 환경 설정을 진행해 주는데 프로젝트 루트 폴더에 package.json 을 생성하자. package.json에서는 client 디렉터리에서 클라이언트 모듈을 실행하고 , 루트 디렉터리에서는 서버 모듈을 실행하도록 명시해 주자. package.json12345678910111213141516171819202122232425262728293031&quot;name&quot;: &quot;management&quot;,&quot;version&quot;: &quot;1.0.0&quot;,&quot;scripts&quot;: {&quot;client&quot;: &quot;cd client &amp;&amp; yarn start&quot;,&quot;server&quot;: &quot;nodemon server.js&quot;,&quot;dev&quot;: &quot;concurrently --kill-others-on-fail \\&quot;yarn server\\&quot; \\&quot;yarn client\\&quot;&quot;},&quot;dependencies&quot;: {&quot;body-parser&quot;: &quot;^1.18.3&quot;,&quot;express&quot;: &quot;^4.16.4&quot;},&quot;devDependencies&quot;: {&quot;concurrently&quot;: &quot;^4.0.1&quot;}} 그런 다음 프로젝트의 루트 디렉터리에 클라이언트와 동일한 형태의 .gitignore 파일을 위치 시키자. .gitignore 파일이 없으면 설치한 노드 모듈이 전부 깃허브에 올라가기 때문에 비효율적이다. 이후에는 루트 디렉터리에서 nodemon을 설치하자 12npm install -g nodemonyarn 여기까지 진행하면 다음과 같은 구조가 된다 결과 화면 이제 서버 모듈 개발을 위해 루트 디렉터리에 server.js 파일을 생성한다. server.js123456789101112131415const express = require('express');const bodyParser = require('body-parser');const app = express();const port = process.env.PORT || 5000;app.use(bodyParser.json());app.use(bodyParser.urlencoded({extended: true}));app.get('/api/hello/', (req,res) =&gt;{ res.send({ message: &quot;Hello Express!&quot;});});app.listen(port, () =&gt; console.log(`Listening on port ${port}`)); 서버를 구동 시킨 후 브라우저 주소창에 localhost:5000/api/hello 를 쳐보자 1node server.js 결과 화면","link":"/2020/09/03/project-7/"},{"title":"React와 Node.js로 만드는 고객 관리 시스템 개발-8","text":"Express에서 REST API 구축하기REST API는 상당수의 웹 서버 프레임워크에서 기본적으로 지원하는 기능으로 클라이언트가 웹 프로토콜을 기반으로 하여 효과적으로 데이터를 주고 받을 수 있도록 해준다. 이를 실습하기 위해 전체 고객 목록을 불러오는 API를 구현해 보자. 실제로는 DB에 연동해서 정보를 불러오는 형태로 개발해야 하지만 일단 하드코딩으로 해보자. server.js123456789101112131415161718192021222324252627282930313233343536373839const express = require('express');const bodyParser = require('body-parser');const app = express();const port = process.env.PORT || 5000;app.use(bodyParser.json());app.use(bodyParser.urlencoded({extended: true}));app.get('/api/customers/', (req,res) =&gt;{ res.send([{ 'id': 1, 'image': 'https://placeimg.com/64/64/any', 'name': '염소', 'birthday':'031223', 'gender':'여자', 'job':'대학생' }, { 'id': 2, 'image': 'https://placeimg.com/64/64/2', 'name': '최동욱', 'birthday': '951211', 'gender': '남자', 'job': '인턴' }, { 'id': 3, 'image': 'https://placeimg.com/64/64/3', 'name': '털보', 'birthday': '961127', 'gender': '남자', 'job': '개' }]);});app.listen(port, () =&gt; console.log(`Listening on port ${port}`)); ​ 그런 다음 서버를 재 가동하고 api/customers 경로에 들어가보면 다음과 같이 출력된다. 이후에 클라이언트에서 해당 API에 접근하여 고객 목록을 비동기적으로 가져오도록 만들자. 가장 먼저 5000번 포트를 API서버로 이용하기 위해 클라이언트의 package.json 파일에 다음을 추가하자. package.json123&quot;proxy&quot;: &quot;http://localhost:5000/&quot; 이제 app.js 파일을 작성하여 실제로 API 서버에 접근할 수 있도록 처리하면 된다. 비동기적인 API 요청 기능을 수행하기 위해서 async-await 구문을 사용하자 . 서버로부터 JSON 데이터를 받아올 때까지는 테이블에 내용을 출력하지 않다가 데이터를 모두 받아오면 내용을 채우게 된다. app.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import React, {Component} from 'react';import Customer from './components/Customer'import './App.css';import Paper from '@material-ui/core/Paper';import Table from '@material-ui/core/Table';import TableHead from '@material-ui/core/TableHead';import TableBody from '@material-ui/core/TableBody';import TableRow from '@material-ui/core/TableRow';import TableCell from '@material-ui/core/TableCell';import { withStyles } from '@material-ui/core/styles';const styles = theme =&gt; ({ root: { width: &quot;100%&quot;, marginTop: theme.spacing.unit * 3, overflowX: &quot;auto&quot; }, table: { minWidth: 1080 }});class App extends Component{ state = { customers: '' } componentDidMount(){ this.callApi() .then(res =&gt; this.setState({customers:res})) .catch(err =&gt; console.log(err)); } callApi = async() =&gt;{ const response = await fetch('/api/customers'); const body = await response.json(); return body; } render(){ const { classes } = this.props; return ( &lt;Paper className = {classes.root}&gt; &lt;Table className = {classes.table}&gt; &lt;TableHead&gt; &lt;TableRow&gt; &lt;TableCell&gt; 번호 &lt;/TableCell&gt; &lt;TableCell&gt; 이미지 &lt;/TableCell&gt; &lt;TableCell&gt; 이름 &lt;/TableCell&gt; &lt;TableCell&gt; 생년월일 &lt;/TableCell&gt; &lt;TableCell&gt; 성별 &lt;/TableCell&gt; &lt;TableCell&gt; 직업 &lt;/TableCell&gt; &lt;/TableRow&gt; &lt;/TableHead&gt; &lt;TableBody&gt; {this.state.customers ? this.state.customers.map(c =&gt; { return &lt;Customer key={c.id} id={c.id} image={c.image} name={c.name} birthday={c.birthday} gender={c.gender} job={c.job} /&gt; }) : ''} &lt;/TableBody&gt; &lt;/Table&gt; &lt;/Paper&gt; ); }}export default withStyles(styles)(App); 이제 서버 모듈 개발을 위해 루트 디렉터리에 server.js 파일을 생성한다. server.js123456789101112131415const express = require('express');const bodyParser = require('body-parser');const app = express();const port = process.env.PORT || 5000;app.use(bodyParser.json());app.use(bodyParser.urlencoded({extended: true}));app.get('/api/hello/', (req,res) =&gt;{ res.send({ message: &quot;Hello Express!&quot;});});app.listen(port, () =&gt; console.log(`Listening on port ${port}`)); 이후 yarn dev 명령어를 이용해 서버를 구동시키자 1yarn dev 결과 화면","link":"/2020/09/03/project-8/"},{"title":"React와 Node.js로 만드는 고객 관리 시스템 개발-9","text":"React의 라이프 사이클 및 API 로딩 처리이번에는 API 로딩 메시지를 웹 사이트 상에 출력해보자 프로그레스 바 UI 는 Material UI에 이미 구현되어 있다. Material UI 프로그레스 바 : https://material-ui.com/demos/progress/ React의 라이프 사이클 기본적으로 React 라이브러리가 처음 컴포넌트를 실행할 때는 다음의 순서를 따른다. constructor() componentWillMount() render() componentDidMount() 그리고 컴포넌트의 props 혹은 state가 변경될 때는 shouldComponentUpdate() 함수 등이 사용되어 실질적으로 다시 render() 함수를 불러와 뷰를 갱신하게 된다. 또한 컴포넌트가 삭제될 때는 componentWillMount() 함수가 실행된다는 특징이 있다. 따라서 일반적으로 API를 불러와서 웹 사이트 화면에 특정한 뷰를 출력하고자 한다면 componentDidMount() 함수에서 API를 비동기적으로 호출하면 된다. 이후에 API에서 응답이 돌아왔을 때 뷰가 갱신되므로 API 응답 결과를 출력할 수 있다. 비동기적으로 호출한다는 점에서 API 서버에서 응답하지 않으면 사용자에게 로딩 화면만 출력이 된다. Circular Progress 라이브러리를 이용하여 프로그레스 바를 API 로딩 메시지로 사용하자. App.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import React, {Component} from 'react';import Customer from './components/Customer'import './App.css';import Paper from '@material-ui/core/Paper';import Table from '@material-ui/core/Table';import TableHead from '@material-ui/core/TableHead';import TableBody from '@material-ui/core/TableBody';import TableRow from '@material-ui/core/TableRow';import TableCell from '@material-ui/core/TableCell';import CircularProgress from '@material-ui/core/CircularProgress'import { withStyles } from '@material-ui/core/styles';const styles = theme =&gt; ({ root: { width: &quot;100%&quot;, marginTop: theme.spacing.unit * 3, overflowX: &quot;auto&quot; }, table: { minWidth: 1080 }, progress:{ margin: theme.spacing.unit *2 }});class App extends Component{ state = { customers: '', completed: 0 } componentDidMount(){ this.timer = setInterval(this.progress,20); this.callApi() .then(res =&gt; this.setState({customers:res})) .catch(err =&gt; console.log(err)); } componentWillUnmount(){ clearInterval(this.timer); } callApi = async() =&gt;{ const response = await fetch('/api/customers'); const body = await response.json(); return body; } progress = () =&gt; { const {completed } = this.state; this.setState({ completed:completed &gt;=100?0 : completed +1}); }; render(){ const { classes } = this.props; return ( &lt;Paper className = {classes.root}&gt; &lt;Table className = {classes.table}&gt; &lt;TableHead&gt; &lt;TableRow&gt; &lt;TableCell&gt; 번호 &lt;/TableCell&gt; &lt;TableCell&gt; 이미지 &lt;/TableCell&gt; &lt;TableCell&gt; 이름 &lt;/TableCell&gt; &lt;TableCell&gt; 생년월일 &lt;/TableCell&gt; &lt;TableCell&gt; 성별 &lt;/TableCell&gt; &lt;TableCell&gt; 직업 &lt;/TableCell&gt; &lt;/TableRow&gt; &lt;/TableHead&gt; &lt;TableBody&gt; {this.state.customers ? this.state.customers.map(c =&gt; { return &lt;Customer key={c.id} id={c.id} image={c.image} name={c.name} birthday={c.birthday} gender={c.gender} job={c.job} /&gt; }) : ''} &lt;/TableBody&gt; &lt;/Table&gt; &lt;/Paper&gt; ); }}export default withStyles(styles)(App); 결과 화면","link":"/2020/09/03/project-9/"},{"title":"React와 Node.js로 만드는 고객 관리 시스템 개발-10","text":"AWS RDS 서비스를 이용한 DB 연동AWS RDS로 데이터 베이스 만들어 보자 MySQL Workbench 위에까지 하다가 오류가 발생해서 AWS 설정을 바꿨는데 이게 굉장히 오래 걸려서 중간에 잘려먹었다. 퍼블릭 액세스를 아니오 라고 설정했던 것이 원인이었는데 예로 변경하였더니 정상 작동하였다. Workbench와 연동하는 방법은 엔드포인트 주소를 호스트에 입력하고 데이터베이스를 생성할 때 설정했던 ID 와 비밀번호를 쳐서 연동하면 된다. 연동이 되면 새로운 스키마를 작성하고 다음과 같이 고객 테이블을 구축하자. reactexample123456789101112131415161718192021222324252627282930313233343536373839404142USE reactexample;CREATE TABLE CUSTOMER ( id INT PRIMARY KEY AUTO_INCREMENT, image VARCHAR(1024), name VARCHAR(64), birthday VARCHAR(64), gender VARCHAR(64), job VARCHAR(64)) DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;INSERT INTO CUSTOMER VALUES ( 1, 'https://placeimg.com/64/64/any', '염소', '031223', '여자', '대학생'); INSERT INTO CUSTOMER VALUES ( 2, 'https://placeimg.com/64/64/2', '최동욱', '951211', '남자', '인턴'); INSERT INTO CUSTOMER VALUES ( 3, 'https://placeimg.com/64/64/3CUSTOMER', '털보', '961127', '남자', '개'); 결과 화면 gitignore 데이터베이스 관련 정보가 깃허브에 올라가지 않도록 서버 쪽 .gitignore 파일을 수정하자 .gitignore12# database/database.json ​ 이후에 database.json 에서 데이터베이스 정보를 설정하면 된다 database.json1234567891011{ &quot;host&quot;: 데이터베이스 주소, &quot;user&quot;: 데이터베이스 사용자, &quot;password&quot;: 데이터베이스 비밀번호, &quot;port&quot;: &quot;3306&quot;, &quot;database&quot;: 데이터베이스 이름} Node.js와 MySQL 연동하기 먼저 NPM을 통해서 MySQL 라이브러리를 설치하자. 1npm install -S mysql 설치된 MySQL 라이브러리를 활용해서 연동이 가능하다. server.js123456789101112131415161718192021222324252627282930const fs = require('fs');const express = require('express');const bodyParser = require('body-parser');const app = express();const port = process.env.PORT || 5000;app.use(bodyParser.json());app.use(bodyParser.urlencoded({extended: true}));const data = fs.readFileSync('./database.json');const conf = JSON.parse(data);const mysql = require('mysql');const connection = mysql.createConnection({ host : conf.host, user : conf.user, password: conf.password, port : conf.port, database: conf.database});connection.connect();app.get('/api/customers/', (req,res) =&gt;{ connection.query( 'SELECT * FROM CUSTOMER', (err , rows, fields) =&gt; { res.send(rows); } )});app.listen(port, () =&gt; console.log(`Listening on port ${port}`)); 결과 화면","link":"/2020/09/04/project-10/"},{"title":"React와 Node.js로 만드는 고객 관리 시스템 개발-11","text":"고객 추가 양식 구현하기React에서 Form 을 처리하기 위해서는 Event Handling 을 수행해야 한다. 이번에는 서버로 고객 데이터를 전송하여 데이터베이스에 신규 고객 정보를 등록하는 방법을 알아보자. 먼저 React 클라이언트의 components 폴더에 CustomerAdd.js 를 만들자. 그 다음 서버와의 통신 목적의 라이브러리 axios 를 설치해 주자. client 폴더로 이동하여 아래와 같이 입력해주자 1npm install --save axios 그 다음 CustomerAdd.js 를 작업해 주자. CustomerAdd.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import React from 'react'import {post} from 'axios'class CustomerAdd extends React.Component{ constructor(props){ super(props); this.state= { file:null, userName:'', birthday:'', gender: '', job: '', fileName:'' } this.handleFormSubmit = this.handleFormSubmit.bind(this) this.handleFileChange = this.handleFileChange.bind(this) this.handleValueChange = this.handleValueChange.bind(this) this.addCustomer = this.addCustomer.bind(this) } handleFormSubmit(e){ e.preventDefault() this.addCustomer() .then((response)=&gt;{ console.log(response.data); }) } handleFileChange(e){ this.setState({ file: e.target.files[0], fileName: e.target.value }); } handleValueChange(e){ let nextState ={}; nextState[e.target.name] = e.target.value; this.setState(nextState); } addCustomer(){ const url = '/api/customers'; const formData = new FormData(); formData.append('image',this.state.file) formData.append('name',this.state.userName) formData.append('birthday',this.state.birthday) formData.append('gender',this.state.gender) formData.append('job',this.state.job) const config = { headers: { 'content-type': 'multipart/form-data' } } return post(url,formData,config) } render() {return ( &lt;form onSubmit={this.handleFormSubmit}&gt; &lt;h1&gt;고객 추가&lt;/h1&gt; 프로필 이미지: &lt;input type=&quot;file&quot; name=&quot;file&quot; file={this.state.file} value={this.state.fileName} onChange={this.handleFileChange} /&gt;&lt;br/&gt; 이름: &lt;input type=&quot;text&quot; name=&quot;userName&quot; value={this.state.userName} onChange={this.handleValueChange} /&gt;&lt;br/&gt; 생년월일: &lt;input type=&quot;text&quot; name=&quot;birthday&quot; value={this.state.birthday} onChange={this.handleValueChange} /&gt;&lt;br/&gt; 성별: &lt;input type=&quot;text&quot; name=&quot;gender&quot; value={this.state.gender} onChange={this.handleValueChange} /&gt;&lt;br/&gt; 직업: &lt;input type=&quot;text&quot; name=&quot;job&quot; value={this.state.job} onChange={this.handleValueChange} /&gt;&lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;추가하기&lt;/button&gt; &lt;/form&gt; ) } }export default CustomerAdd 그 다음 App.js 를 작업해 주자. CustomerAdd 컴포넌트를 화면에 출력하기 위해서 CustomerAdd를 import 해주고 CustomerAdd.js123import CustomerAdd from './components/CustomerAdd'; render 부분을 다음과 같이 바꿔주자 CustomerAdd.js1234567891011121314151617181920212223&lt;div&gt; &lt;Paper className = {classes.root}&gt; &lt;Table className = {classes.table}&gt; &lt;TableHead&gt; &lt;TableRow&gt; &lt;TableCell&gt; 번호 &lt;/TableCell&gt; &lt;TableCell&gt; 이미지 &lt;/TableCell&gt; &lt;TableCell&gt; 이름 &lt;/TableCell&gt; &lt;TableCell&gt; 생년월일 &lt;/TableCell&gt; &lt;TableCell&gt; 성별 &lt;/TableCell&gt; &lt;TableCell&gt; 직업 &lt;/TableCell&gt; &lt;/TableRow&gt; &lt;/TableHead&gt; &lt;TableBody&gt; {this.state.customers ? this.state.customers.map(c =&gt; { return &lt;Customer key={c.id} id={c.id} image={c.image} name={c.name} birthday={c.birthday} gender={c.gender} job={c.job} /&gt; }) : ''} &lt;/TableBody&gt; &lt;/Table&gt; &lt;/Paper&gt; &lt;CustomerAdd/&gt; &lt;/div&gt; 그러면 다음과 같은 입력창이 생기는데 추가하기를 눌러주면 서버로 전송되는 것을 확인 할 수 있다. 결과 화면","link":"/2020/09/04/project-11/"},{"title":"React와 Node.js로 만드는 고객 관리 시스템 개발-12","text":"Express 에서 파일 업로드 요청 처리 및 DB 데이터 삽입사용자가 보낸 고객 데이터를 Node.js Express로 처리하여 서버의 특정한 폴더에 업로드 하는 방법에 대해서 알아보자. 이후에 MySQL DB에 삽입하고 , 클라이언트에서 접근할 수 있도록 처리해보자. 먼저 CustomerAdd.js의 handleFormSubmit() 을 수정해주자. 데이터를 전송한 이후에 고객 추가 양식을 비운 뒤 페이지를 새로고침하여 고객 데이터를 확인하는 것이다. 실제 배포 버전에서는 이런쪽으로 코딩하면 안되지만 빠른 테스트를 위해서 해보자. CustomerAdd.js12345678910111213141516handleFormSubmit(e){ e.preventDefault() this.addCustomer() .then((response)=&gt;{ console.log(response.data); }) this.setState({ file: null, userName: '', birthday: '', gender: '', job: '', fileName: '' }) window.location.reload(); } 이제 node.js에서 이러한 파일 업로드 요청을 처리하면 된다. 이 때 multer 라이브러리를 사용하므로 루트 디렉터리에서 다음과 같이 명령어 입력하자 그리고 upload 폴더를 생성하자 12npm install --save multermkdir upload 그 다음 server.js 도 수정해 주자. server.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const fs = require('fs');const express = require('express');const bodyParser = require('body-parser');const app = express();const port = process.env.PORT || 5000;app.use(bodyParser.json());app.use(bodyParser.urlencoded({extended: true}));const data = fs.readFileSync('./database.json');const conf = JSON.parse(data);const mysql = require('mysql');const multer = require('multer');const upload = multer({dest:'./upload'})const connection = mysql.createConnection({ host : conf.host, user : conf.user, password: conf.password, port : conf.port, database: conf.database});connection.connect();app.get('/api/customers', (req,res) =&gt;{ connection.query( 'SELECT * FROM CUSTOMER', (err , rows, fields) =&gt; { res.send(rows); } )});app.use('/image',express.static('./upload'));app.post('/api/customers', upload.single('image'),(req,res)=&gt;{ let sql = &quot;INSERT INTO CUSTOMER VALUES (null,?,?,?,?,?)&quot;; let image= '/image/' + req.file.filename; let name = req.body.name; let birthday = req.body.birthday; let gender = req.body.gender; let job = req.body.job; let params = [image, name , birthday , gender , job]; connection.query(sql,params, (err,rows,fields)=&gt; { res.send(rows); })});app.listen(port, () =&gt; console.log(`Listening on port ${port}`)); 그런 다음 .gitignore 에 upload 폴더를 추가해 주자. .gitignore12# upload/upload 결과 화면","link":"/2020/09/04/project-12/"},{"title":"React와 Node.js로 만드는 고객 관리 시스템 개발-13","text":"부모 컴포넌트의 State변경을 통한 고객 정보 갱신지금까지는 정보가 추가되면 새로고침을 통해서 확인할 수 있었다. 하지만 리액트는 기본적으로 SPA(Single Page Application) 구조로 동작하므로 전체 페이지를 새로고침하는 것은 비효율적이다. 이럴때는 고객 추가(Customer Add) 컴포넌트에서 부모 컴포넌트의 State를 변경하는 식으로 필요한 부분만 새로고침 하도록 설정하면 된다. (Props를 전달) 전체 고객 목록 다시 불러오기 가장 대표적인 방법은 전체 고객 목록을 다시 불러옴으로써 State를 갱신하는 방식이다. App.js 를 다음과 같이 변경하자 App.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import React, {Component} from 'react';import Customer from './components/Customer'import './App.css';import Paper from '@material-ui/core/Paper';import Table from '@material-ui/core/Table';import TableHead from '@material-ui/core/TableHead';import TableBody from '@material-ui/core/TableBody';import TableRow from '@material-ui/core/TableRow';import TableCell from '@material-ui/core/TableCell';import CircularProgress from '@material-ui/core/CircularProgress'import { withStyles } from '@material-ui/core/styles';import CustomerAdd from './components/CustomerAdd';const styles = theme =&gt; ({ root: { width: &quot;100%&quot;, marginTop: theme.spacing.unit * 3, overflowX: &quot;auto&quot; }, table: { minWidth: 1080 }, progress:{ margin: theme.spacing.unit *2 }});class App extends Component{ constructor(props){ super(props); this.state= { customers: '', completed: 0 } this.stateRefresh = this.stateRefresh.bind(this); } stateRefresh(){ this.setState({ customers:'', completed: 0 }); this.callApi() .then(res =&gt; this.setState({customers: res})) .catch(err =&gt; console.log(err)); } componentDidMount(){ this.timer = setInterval(this.progress,20); this.callApi() .then(res =&gt; this.setState({customers:res})) .catch(err =&gt; console.log(err)); } componentWillUnmount(){ clearInterval(this.timer); } callApi = async() =&gt;{ const response = await fetch('/api/customers'); const body = await response.json(); return body; } progress = () =&gt; { const {completed } = this.state; this.setState({ completed:completed &gt;=100?0 : completed +1}); }; render(){ const { classes } = this.props; return ( &lt;div&gt; &lt;Paper className = {classes.root}&gt; &lt;Table className = {classes.table}&gt; &lt;TableHead&gt; &lt;TableRow&gt; &lt;TableCell&gt; 번호 &lt;/TableCell&gt; &lt;TableCell&gt; 이미지 &lt;/TableCell&gt; &lt;TableCell&gt; 이름 &lt;/TableCell&gt; &lt;TableCell&gt; 생년월일 &lt;/TableCell&gt; &lt;TableCell&gt; 성별 &lt;/TableCell&gt; &lt;TableCell&gt; 직업 &lt;/TableCell&gt; &lt;/TableRow&gt; &lt;/TableHead&gt; &lt;TableBody&gt; {this.state.customers ? this.state.customers.map(c =&gt; { return &lt;Customer key={c.id} id={c.id} image={c.image} name={c.name} birthday={c.birthday} gender={c.gender} job={c.job} /&gt; }) : &lt;TableRow&gt; &lt;TableCell colSpan=&quot;6&quot; align=&quot;center&quot;&gt; &lt;CircularProgress className={classes.progress} variant=&quot;determinate&quot; value={this.state.completed} /&gt; &lt;/TableCell&gt; &lt;/TableRow&gt; } &lt;/TableBody&gt; &lt;/Table&gt; &lt;/Paper&gt; &lt;CustomerAdd stateRefresh={this.stateRefresh}/&gt; &lt;/div&gt; ); }}export default withStyles(styles)(App); CustomerAdd 컴포넌트로 stateRefresh()함수를 보내면 CustomerAdd 컴포넌트가 부모 컴포넌트인 App 컴포넌트의 State를 갱신하게 된다. CustomerAdd.js에 가서 window.location.reload() 함수를 제거하고 다음의 구문을 넣자. CustomerAdd.js1this.props.stateRefresh(); 다만 고객 목록 데이터를 불러오는 과정은 비동기적으로 수행된다는 점에서 항상 고객 데이터를 추가한 이후에 고객 목록 데이터를 불러온다는 것을 보장하지 못한다. 따라서 다음과 같이 고객 추가 이후에 서버로부터 응답을 받고 나서 고객 목록을 다시 불러오도록 설정해야한다 CustomerAdd.js1234567891011121314151617handleFormSubmit(e){ e.preventDefault() this.addCustomer() .then((response)=&gt;{ console.log(response.data); this.props.stateRefresh(); }) this.setState({ file: null, userName: '', birthday: '', gender: '', job: '', fileName: '' }) }","link":"/2020/09/04/project-13/"},{"title":"","text":"이렇게 해도 올라가나","link":"/2020/09/04/%EA%B3%B5%EB%B6%80/%EA%B3%B5%EB%B6%80/"}],"tags":[],"categories":[{"name":"Test","slug":"Test","link":"/categories/Test/"},{"name":"인턴","slug":"인턴","link":"/categories/%EC%9D%B8%ED%84%B4/"},{"name":"JS","slug":"인턴/JS","link":"/categories/%EC%9D%B8%ED%84%B4/JS/"},{"name":"React.js","slug":"인턴/React-js","link":"/categories/%EC%9D%B8%ED%84%B4/React-js/"},{"name":"Node.js","slug":"인턴/Node-js","link":"/categories/%EC%9D%B8%ED%84%B4/Node-js/"},{"name":"React + Node.js","slug":"인턴/React-Node-js","link":"/categories/%EC%9D%B8%ED%84%B4/React-Node-js/"}]}