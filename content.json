{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/08/31/hello-world/"},{"title":"마크다운 문법","text":"H1 은 = 여러개로 첫번째 두번째 세번째 print(\"코드는 pre code 태그로 감싸주거나 \") 1그레이브 엑센트 3개로 감싸준다 링크 CodePen에서 실행하기 인용 안녕하세요","link":"/2020/09/01/1%EC%9D%BC%EC%B0%A8-2/"},{"title":"1일차","text":"thisthis 란? JS는 스크립트 언어로 인터프리터가 코드를 라인 단위로 읽고 해석한 뒤 실행시킨다. 인터프리터에 의해 현재 실행되는 자바스크립트 코드의 scope를 실행 컨텐스트라고 부른다. JS에서는 이런 실행 컨텍스트를 stack으로 관리하고 있으며 this는 현재 실행되는 코드의 실행 컨텍스트를 가리킨다. 이는 일반적으로 메소드를 호출한 객체가 저장되어 있는 속성이다. 기본적으로 this는 전역 객체를 가리키는데 Node환경에서는 global , Browser에서는 Window를 가리킨다. 1234567891011function MyClass() { this.property1 = &quot;value1&quot;;}MyClass.prototype.method1 = function(){ console.log(this.property1);}var my1 = new MyClass();my1.method1(); 메소드를 호출한 객체는 my1이고 method1은 메소드가 된다. method1()이 실행되면 메소드 내부에는 자바스크립트 엔진에 의해 this 속성이 생기게 된다. 이 this에는 method1을 호출한 my1 객체가 저장된다. 1. 일반 함수에서의 this 12345678910111213141516var data = 10; //1function outer(){ this.data = 20; //2 data = 30; //3 console.log(&quot;1. data = &quot; + data); console.log(&quot;2. this.data = &quot; + this.data); console.log(&quot;3. window.data = &quot; + window.data);}outer();/*1. data = 302. this.data = 303. window.data = 30*/ 일반 함수 내부에서는 this 가 전역 객체인 window 객체를 저장한다.2의 data는 window.data 와 동일하기 때문에 1의 data에 20이 저장된다.3에서는 먼저 지역 변수 내에서 data를 찾고 없으면 outer를 호출한 영역에서 찾기 때문에 마찬가지로 전역변수인 data에 30을 저장한다=&gt; 1,2,3의 data 모두 전역 변수인 data(1의 data)를 나타낸다. 2. 중첩 함수에서의 this 12345678910111213141516171819var data = 10; //1function outer(){ function inner(){ this.data = 20; //2 data = 30; //3 console.log(&quot;1. data = &quot; + data); console.log(&quot;2. this.data = &quot; + this.data); console.log(&quot;3. window.data = &quot; + window.data); } inner();}outer();/*1. data = 302. this.data = 303. window.data = 30*/ 일반 중첩 함수에서 this 역시 window가 된다.2의 this.data는 1의 data와 동일하므로 1의 data에 20이 저장된다.3의 data는 우선 지역 변수 내에서 data를 찾고, 없다면 outer를 호출한 영역에서 data를 찾습니다. inner와 outer 모두 data가 없기 때문에, 3의 data 역시 1의 전역 변수인 data가 된다.=&gt; 1,2,3의 data 모두 전역 변수인 data(1의 data)를 나타낸다. 3. Event Listener에서의 this 123456789101112131415var data = 10; //1$(&quot;#myButton&quot;).click(function() { this.data = 20; //2 data = 30; //3 console.log(&quot;1. data = &quot; + data); console.log(&quot;2. this.data = &quot; + this.data); console.log(&quot;3. window.data = &quot; + window.data); });/*1. data = 302. this.data = 203. window.data = 30*/ 이벤트 리스너에서는 this가 이벤트를 발생시킨 객체가 된다.그러므로 this가 #myButton이 되고 2는 #myButton에 data라는 property를 동적으로 추가하는 구문이 된다.3의 data는 우선 지역 변수내에서 data를 찾고 없다면 상위 영역에서 data를 찾는다. 결국 3의 data는 1의 전역 변수 data가 되어 30을 저장한다 4. 메소드에서의 this 123456789101112131415161718192021var data = 10; //1function MyClass(){ this.data = 0;}MyClass.prototype.method1 = function(){ this.data = 20; //2 data = 30; //3 console.log(&quot;1. data = &quot; + data); console.log(&quot;2. this.data = &quot; + this.data); console.log(&quot;3. window.data = &quot; + window.data); } var my1 = new MyClass(); my1.method1();/*1. data = 302. this.data = 203. window.data = 30*/ (객체의 property가 함수인 경우 이를 메소드라고 부른다)메소드에서는 this가 메소드를 호출한 객체가 된다.2의 data는 객체의 property가 되어 코드 my1.data에 20이 저장된다.3의 data는 우선 지역 변수 내에서 data를 찾고, 없으면 상위 영역에서 data를 찾게 됩니다. 결국 3의 data는 1의 전역 변수 data가 되어 30을 저장한다. 5. 메소드 내부의 중첩 함수에서의 this 123456789101112131415161718192021222324var data = 10; //1function MyClass(){ this.data = 0;}MyClass.prototype.method1 = function(){ function inner(){ this.data = 20; //2 data = 30; //3 console.log(&quot;1. data = &quot; + data); console.log(&quot;2. this.data = &quot; + this.data); console.log(&quot;3. window.data = &quot; + window.data); } inner();} var my1 = new MyClass(); my1.method1();/*1. data = 302. this.data = 203. window.data = 30*/ 객체의 메소드 내부에서 만들어지는 중첩 함수에서 this는 객체가 아닌 window가 된다.2의 data는 1의 전역 변수가 되어 1의 data에 20이 저장된다.3의 data는 우선 지역 변수 내에서 data를 찾고, 없으면 상위 영역에서 data를 찾게 됩니다. 결국 3의 data는 1의 전역 변수 data가 되어 30을 저장한다.=&gt; 1,2,3의 data 모두 전역 변수인 data(1의 data)를 나타낸다. 요약 this가 만들어지는 경우 this가 가리키는 것 일반 함수 window 중첩 함수 window 이벤트 이벤트 객체 메소드 메소드 객체 메소드 내부 중첩 함수 window 출처 : https://beomy.tistory.com/6","link":"/2020/09/01/1%EC%9D%BC%EC%B0%A8-3/"},{"title":"1일차","text":"JS 문법 공부(ES 6)인턴 1일차 JS문법공부 (ES 6) 하고 난 뒤에 node.js / React.js / db 설계 공부예정 ES 6 사수님께서 ES6를 공부하라고 하셔서 ES6가 뭐고 왜 쓰는지 먼저 알아 보았다.초기에는 특정 브라우저에서만 동작하는 JS가 있어서 모든 브라우저에서 호환이 되는표준 규격을 만들었고 그것이 ECMA 국제기구에서 만든 ECMA Script이다.그리고 회사에서 사용하는 React 등 최신 프레임워크들은 ES6를 기반으로 하고 있기 때문에ES6를 공부하게 된 것이다. 추가적으로 유튜브에서 공부할 때 보았던 Babel이라는 트랜스파일러를 사용하는 이유도 알 수 있었는데웹 브라우저에서 완벽하게 지원되지 않아서 상위버전 ES를 하위버전 ES로 변환해 주는 역할을 한다고 한다. ES6에서 대표적으로 추가된 기능은 3가지 정도가 있다. 1. Var와 Let , Const 일단 세가지 키워드 모두 선언 방법은 동일하다. 123var v1 = 4;let v2 = 4;const v3 = 4; ES6에서는 var 대신 let과 const를 쓴다고 하는데 이들의 차이점을 알아보았다. 1.1 호이스팅 (Hoisting) var로 선언한 변수는 호이스팅이 된다는 특징이 있다. 호이스팅이란 끌어올린다는 뜻으로 변수의 선언보다 대입이 먼저 이루어질 때 일어난다 123hoisting = 1;var hoisting;console.log(hoisting); // 1 하지만 let과 const는 호이스팅을 시도할 경우 에러가 난다. 1234hoisting = 1;let hoisting;console.log(hoisting); // error 1234hoisting = 1;const hoisting;console.log(hoisting); // error 1.2 변수 스코프 var는 함수 스코프만 적용되고 블록 스코프는 적용되지 않는다. 12345678//함수 스코프var a = 100;function f() { var a = 200; console.log(a); // 200}f();console.log(a); //100 12345678//블록 스코프var a = 100;if(a&gt;0){ var a =200; /*var a = 300; // error가 발생하지 않는다 */ console.log(a); //200}console.log(a); //200 블록 스코프 예제에서 두번째 콘솔에 찍힌 a값이 200인 이유는 var변수 사용시 함수 블록에 대한 스코프만 제공하기 때문에 변수가 블록 안에 있던 밖에 있던 공유되기 때문이다. 1234567let a = 100;if(a&gt;0){ let a = 200; /*let a = 100; // error ( a = 100; 은 가능하다.)*/ console.log(a); // 200}console.log(a); //100 1234567const a = 100;if(a&gt;0){ const a = 200; /*const a = 100; // error ( a = 100; 도 불가능하다.)*/ console.log(a); // 200}console.log(a); //100 let 과 const는 모든 블록에 대한 스코프가 생기고 중복 선언이 불가능하다. 2. 화살표 함수(Arrow Function) ES6에서는 화살표 함수를 이용해 함수를 정의하는 방법이 추가되었다. 일반적인 JS의 함수 선언 방법은 다음과 같다 123function FunctionName(){} 그리고 이렇게 선언된 함수는 다음과 같이 실행할 수 있다 1FunctionName(); 2.1 사용법 화살표 함수는 보다 간편한 방법으로 선언하기 위해 다음과 같이 선언한다. 1234567891011121314151617() =&gt; { ... } // 매개변수가 없을 경우 x =&gt; { ... } // 매개변수가 한 개인 경우, 소괄호를 생략할 수 있다.(x, y) =&gt; { ... } // 매개변수가 여러 개인 경우, 소괄호를 생략할 수 없다.x =&gt; { return x * x } // single line blockx =&gt; x * x // 함수 몸체가 한줄의 구문이라면 중괄호를 생략할 수 있으며 암묵적으로 return된다. 위 표현과 동일하다.() =&gt; { return { a: 1 }; }() =&gt; ({ a: 1 }) // 위 표현과 동일하다. 객체 반환시 소괄호를 사용한다.() =&gt; { // multi line block. const x = 10; return x * x;}; 화살표 함수는 익명 함수로만 사용할 수 있다. 12const pow = x =&gt; x*x;console.log(pow(10)); //100 2.2 this 일반 함수와 화살표 함수의 가장 큰 차이점은 this이다. 일반 함수의 경우 함수를 호출할 때 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정된다. 하지만 화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다. (Lexical this) 12345678910function Prepixer(prefix){ this.prefix = prefix;}Prefixer.prototype.prefixArray = function (arr){ // this는 상위 스코프인 prefixArray 메소드 내의 this를 가리킨다. return arr.map(x =&gt; `${this.prefix} #{x}`);};const pre = new Prefixer('Hi');console.log(pre.prefixArray(['Lee', 'Kim'])); 화살표 함수는 call,apply,bind 메소드를 사용하여 this를 변경할 수 없다. 3. Promise 싱글스레드인 자바스크립트에서 비동기 처리를 위해서 콜백을 사용해왔다.덕분에 비동기 처리를 온전히 해낼 수 있었지만 여러가지 단점들이 있었는데비동기 처리를 중첩시켜서 표현하므로 에러, 예외처리가 어렵다는 것과 중첩으로 인한 복잡도가 증가한다는 것이었다.크게 이 두가지 단점을 해결하기 위해서 생겨난 것이 Promise 이다.","link":"/2020/09/01/1%EC%9D%BC%EC%B0%A8/"},{"title":"2일차","text":"Node.jsNode.js는 Google의 V8 JavaScript 엔진에 기반한 서버 측 기술이다. 쓰레드나 별도 프로세스 대신 비동기 이벤트 위주 I/O를 사용하는 시스템으로 간단한 작업을 수행하지만 접근 빈도가 높은 웹 어플리케이션에 이상적이다. 전통적인 웹 서버 Node 웹 리소스가 요청될 때마다 요청을 처리하기 위해 매번 별도의 스레드를 생성하거나 새로운 프로세스를 호출한다. 이러한 방식은 많은 양의 리소스를 붙잡아 두게 된다. 매 요청마다 태스크를 새롭게 생성하지 않고 특정 이벤트를 기다리고 있다가 해당 이벤트가 발생하면 응답한다. Node는 이벤트 기능이 완료되는 것을 기다리는 동안 다른 요청이 들어오는 것을 차단하지 않으며 이벤트는 비교적 간단한 이벤트 루프 내에서 들어온 순서대로 처리된다. Hello World! 12345678//helloworld.jsvar http = require('http'); // 1http.createServer(function (req,res){ // 2 res.writeHead(200,{'content-type': 'text/plain'}); // 3 res.end(&quot;Hello, World!\\n&quot;); //4}).listen(8124); // asynchronousconsole.log('Server running on 8124'); 다음과 같이 코드를 작성하고 명령 창에서 다음을 입력한다. node helloworld.js 프로그램이 성공적으로 실행되면 다음과 같이 출력된다. Server running on 8124 그 다음 아무 브라우저나 사용해서 `localhost:8124`를 사용하면 아래와 같은 웹 페이지가 표시된다. helloworld.js 의 코드를 살펴보면 Node의 기능 대부분은 모듈이라고 불리는 외부 어플리케이션 및 라이브러리를 통해 제공된다. 1의 코드는 HTTP 모듈을 로드해서 로컬 변수 http에 할당한다. HTTP 모듈은 기본 HTTP 기능을 제공하여 어플리케이션이 네트워크에 접근할 수 있게 해준다. createServer를 사용하여 새로운 서버가 생성되며, 매개변수로 익명 함수가 전달된다. 이 익명 함수는 requestListener 함수로 서버 요청(http.ServerRequest)과 서버 응답(http.ServerResponse)이라는 매개변수들을 가진다. http.ServerResponse 개체는 writeHead라는 메소드를 가지는데 응답 상태와 content-type을 제공하는 응답 헤더를 전송하고 있다. 헤더 생성 코드 다음은 메시지를 쓰는 명령이다. end 메소드는 두 개의 매개변수를 가진다. 문자열이나 버퍼가 될 수 있는 데이터 문자열일 경우 인코딩 방식을 지정 (utf-8이 아닐 경우에만 필요) 또한 4의 코드는 다음과 같이 쓸 수도 있다. 12res.write(&quot;Hello, World!\\n&quot;);res.end();","link":"/2020/09/02/2%EC%9D%BC%EC%B0%A8/"},{"title":"2일차) React.js","text":"1. Hello World 가장 단순한 React 예시는 다음과 같이 생겼다. 1234ReactDOM.render( &lt;h1&gt;Hello, World!&lt;/h1&gt;, document.getElementById('root')); 위 코드는 페이지에 “Hello, world!”라는 제목을 보여준다. CodePen에서 실행하기 2. JSX 아래의 변수 선언을 살펴보자 1const element = &lt;h1&gt;Hello, World!&lt;/h1&gt;; 위와 같은 태그 문법을 JSX라고 하며 JavaScript를 확장한 문법이다. JSX는 React element를 생성한다. JSX에 표현식 표함하기 아래 예시에서는 `name` 이라는 변수를 선언한 후 중괄호로 감싸 JSX 안에 사용하였다. 1234567const name = 'dong wook';const element = &lt;h1&gt;Hello , {name}&lt;/h1&gt;;ReactDOM.render( element, document.getElementById('root')); JSX의 중괄호 안에는 유효한 모든 JavaScript표현식을 넣을 수 있다. 예를 들어 2+2 , user.firstName 또는 formatName(user) 등은 모두 유효한 JavaScript 표현식이다. 아래 예시에서는 JavaScript 함수 호출의 결과인 formatName(user)을 &lt;h1&gt; 엘리멘트에 포함했다. 1234567891011121314151617181920function formatName(user){ return user.firstName + ' ' + user.lastName;}const user = { firstName: &quot;dong wook&quot;, lastName: 'choi'};const element = ( &lt;h1&gt; Hello, {formatName(user)}! &lt;/h1&gt;);ReactDOM.render( element, document.getElementById('root')); CodePen에서 실행하기 JSX도 표현식이다 컴파일이 끝나면, JSX 표현식이 정규 JavaScript 함수 호출이 되고 JavaScript 객체로 인식된다.즉, JSX를 if 구문 및 for loop 안에 사용하고, 변수에 할당하고 , 인자로서 받아들이고, 함수로부터 반환 할 수 있다. 123456function getGreeting(user){ if(user){ return &lt;h1&gt;Hello , {formaaName(user)}!&lt;/h1&gt;; } return &lt;h1&gt;Hello, Stranger. &lt;/h1&gt;;} JSX 속성 정의 속성에 따옴표를 이용해 문자열 리터럴을 정의할 수 있다. const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;; 중괄호를 사용하여 어트리뷰트에 JavaScript표현식을 삽입할 수도 있다. const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;; 어트리뷰트에 JavaScript 표현식을 삽입할 때 중괄호 주변에 따옴표를 입력하지 말자.따옴표 또는 중괄호 중 하나만 사용하고 , 동일한 어트리뷰트에 두 가지를 동시에 사용하면 안된다.[[TIP]] 경고 JSX는 HTML보다는 JavaScript에 가깝기 때문에, React DOM은 HTML 어트리뷰트 이름 대신 camelCase 프로퍼티 명명 규칙을 사용한다.예를 들어 , JSX에서 class는 className 이 되고 tabindex는 tabIndex 가 된다.[[/TIP]] JSX로 자식 정의 태그가 비어있다면 XML처럼 `/>` 를 이용해 바로 닫아주어야 한다. ```javascript const element = ; ``` JSX 태그는 자식을 포함할 수 있다. ```javascript const element=( Hello! Good to see you here. ); ``` JSX는 주입 공격을 방지한다 JSX에 사용자 입력을 삽입하는 것은 안전하다. ```javascript const title = response.potentiallyMaliciousInput; const element = {title}; ``` 기본적으로 React DOM은 JSX에 삽입된 모든 값을 렌더링하기 전에 이스케이프 하므로, 애플리케이션에서 명시적으로 작성되지 않은 내용은 주입되지 않는다. 모든 항목은 렌더링 되기 전에 문자열로 반환된다. 이런 특성으로 인해 XSS 공격을 방지할 수 있다. JSX는 객체를 표현한다. Babel은 JSX를 `React.createElement()` 호출로 컴파일한다. 다음 두 예시는 동일하다. const element = ( &lt;h1 className = &quot;greeting&quot;&gt; Hello, World! &lt;/h1&gt; ); const element = React createElement( 'h1', {className: 'greeting'}, 'Hello, World!' ); React.createElement() 는 버그가 없는 코드를 작성하는 데 도움이 되도록 몇 가지 검사를 수행하며, 기본적으로 다음과 같은 객체를 생성한다. // 주의: 다음 구조는 단순화되었음 const element = { type: 'h1', props: { className: 'greeting', children: 'Hello, world!' } }; 이러한 객체를 “React 엘리먼트”라고 하며, 이를 화면에 표시하려는 항목에 대한 설명이라고 생각할 수 있다. React는 이러한 객체를 읽은 후 DOM을 구성하고 최신으로 유지하는 데 이러한 객체를 사용한다. [[TIP]] 팁 ES6 및 JSX 코드가 올바르게 표시되도록 편집기에 “Babel” 언어 설정을 사용하는 것을 권장. [[/TIP]]","link":"/2020/09/02/2%EC%9D%BC%EC%B0%A8-2/"}],"tags":[],"categories":[{"name":"Test","slug":"Test","link":"/categories/Test/"},{"name":"인턴","slug":"인턴","link":"/categories/%EC%9D%B8%ED%84%B4/"},{"name":"JS","slug":"인턴/JS","link":"/categories/%EC%9D%B8%ED%84%B4/JS/"},{"name":"React.js","slug":"인턴/React-js","link":"/categories/%EC%9D%B8%ED%84%B4/React-js/"},{"name":"Node.js","slug":"인턴/Node-js","link":"/categories/%EC%9D%B8%ED%84%B4/Node-js/"}]}